1. One example of where concurrency could damage our service is when the endpoints /{group_id}/users/{user_id}/purchases is called at the same time as /{uid1}/pay/{uid2}. If the isolation level was lower, it could happen that the PAY endpoint reads the debt between user1 and user2, and then, the PURCHASE endpoint would add or subtract an amount to the amount, and then when PAY set the debt to 0, we lost that PURCHASE amount. This could be solved by ledgerizing the transactions table, as we have for our implementation. This makes all endpoints sum all relevant transactions everytime, and therefore information is never lost. If those two endpoints were called, the new PURCHASE amount would not be settled, but at least we would never lose the information of the transaction.
